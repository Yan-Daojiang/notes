# 可靠、可扩展可维护的应用系统
一个数据密集型应用系统一般会包含这样一些组件：数据库、高速缓存、索引、流处理、批处理等。在构建特定的应用系统时我们可能需要组合应用这些组件，每个组件高效的完成一部分任务，多个组件通过应用层代码驱动有机的衔接起来。

在设计数据密集型应用系统时，需要考虑各种问题，例如：如何应用系统的局部失效，系统降级，负载增加时如何进行扩展以及如何提供友好的 API 服务等。除了这些因素之外还需要考虑系统的依赖，交付周期，风险甚至是监管合规等。不同的应用系统可能需要因时因地的考虑不同的因素。在设计软件应用系统时，有三个极为重要的问题，分别是：**可靠性**、**可扩展性**以及**可维护性**。
* 可靠性：出现意外情况时，系统应该可以正常运行，虽然系统可能降级，但是功能需要确保正确。
* 可扩展性：随着规模的增长，系统应该以合理的方式匹配增长。
* 可维护性：随着时间的推移，新的人员参与到开发与运维，并且可能需要适配新的场景，此时系统仍要高效的运转。

下面将对可靠性、可扩展性以及可维护性做进一步分析。

## 可靠性
通常，可靠性意味着，即使发生了某些错误/故障（faults），系统仍然可以继续高效的工作。系统能够应对 faults 则称为容错（fault-tolerant）或者弹性（resilient）。故障（faults）与失效（failure）并不完全一致。faults 通常定义为组件偏离正常的规格，而失效（failure）则意味着系统整体停止。通常，设计容错机制避免故障引起的失效。故障可能时各种类型的，包括：硬件故障、软件错误以及人为失误。
### 硬件故障
硬件故障是最容易想到的：硬盘故障，内存故障，断网断电等。应对硬件故障最容易想到的是添加硬件冗余，如硬盘配置 RAID，双电源，热插拔 CPU等。通过硬件冗余能够让单台机器完全失效的概率降到非常低的水平。通过备份迅速恢复，一般来说不会造成灾难性故障。

在大规模的机器之上，硬件的故障率也会线性增长。例如对于一些大规模的云平台，强调的是总体灵活性与弹性，而非单台机器的可靠性。此时，软件容错方式成为应对多机失效的一种手段，提高系统的容错性，并可作为硬件容错的有力补充。
### 软件故障
软件故障是另一类故障，由于节点通常是相关的，因此软件故障通常会导致更多的系统故障，并且是难以预料的。例如：Linux 闰秒问题、进程资源共享问题，服务依赖问题以及级联故障等。

导致软件故障的BUG可能长期不会触发，直到达到某些条件。软件故障有时并没有快速的解决方案，只能仔细考虑更多的细节，进行全面的测试，做好隔离，自动重启，做好评估监控等。
### 人为故障
系统的设计和构建是人完成的，同时也需要人来进行运维，但是人总是无法做到万无一失。由于人是不可靠的，而系统是需要保证可靠性的，此时通常有这样一些方法：
* 以最小出错方式来设计系统，例如精心设计的抽象层、API以及界面。使得“做正确的事很容易”，搞坏很复杂。
* 分离最容易出错的地方，容易引发故障的接口。
* 充分测试：从单元测试到全系统集成测试以及手工测试。
* 出现人为失误之后，提供快速恢复机制，尽可能降低故障影响。例如快速回滚配置，滚动发布，提供校验工具等。
* 设置详细而清晰的监控子系统。
* 推行管理以及培训。

## 可扩展性
即使系统现在工作可靠，但并不意味着将来就一定能可靠运转。发生退化的一个原因就是系统负载的增加。可扩展性用来描述系统应对系统负载增加的能力。

在谈到负载的时候，首先需要清晰简洁的描述负载。负载可以用负载参数进行描述，参数的选择取决于系统的体系结构，它可能是系统每秒接受请求的此时，缓存命中率，数据库写入比例等。有时重要的是平均值，而有时系统的瓶颈可能是峰值。

在描述了负载之后，会考虑负载增加会发生什么。一般有两种考虑方式：一是：负载增加，系统资源不变，系统性能会如何变化；二是：负载增加，为了保持性能，需要增加多少资源。两种方式都会关注到系统的性能。那么系统性能又该如何描述呢？

在关注性能的时候，对于批处理系统我们会更加关注吞吐量（throughput），而对于在线系统我们则更加关注响应时间（response time）。我们经常会考虑平均响应时间，但是平均值有时并不能很好的进行描述，最好是使用百分位数（percentiles）。例如，用中位数描述用户的等待时间，如果响应时间中位数为200ms，那么意味着有一半请求不到200ms，而另一半则更长。中位数也称为50百分位数，通常缩写为P50。为了弄清楚系统的异常值，需要关注更大的百分位数：P95、P99、P99.9等。

另外，在测试系统可扩展性时，负载生成端要独立于响应时间持续发送请求，避免在发送请求之前总是等到之前的请求完成，这样可以模拟队头阻塞，避免人为缩短服务端的队列深度，带来测试偏差。
### 应对负载增加的方案
描述了负载参数，负载性能之后需要探讨的是如何应对负载增加。一般针对特定负载设计的系统难以应付超过10倍的实际负载。因此在增长阶段需要根据负载情况考虑架构该如何设计。

应对负载增加可以考虑水平扩展以及垂直扩展，需要在二者之间进行取舍。有时，几个性能强悍的服务器比一堆小型虚拟机来得简单，便宜。

有些系统支持弹性，可以自动检测负载增加并添加资源。然而，如果负载的高度不可预测，自动弹性会更加高效，但是手动扩展可能会减少执行期间的意外情况。

无状态服务的扩展到多台机器会相对容易。而有状态服务扩展到多台机器难度会大大增加。随着分布式技术的发展，分布式数据系统可以提高系统的可扩展性。

超大规模的数据系统往往是真的会特定应用高度定制的，背后会有更多的取舍因素。

设计系统时，扩展能力好的系统通常会做出一些假设，然后针对性的进行优化，如哪些操作是最频繁的，哪些是负载是少数情况，避免浪费在扩展性方面的努力。可扩展性系统也是从通用模块逐步构建的，背后往往也是有规律可循的。

## 可维护性
软件的大部分成本并不在最初的开发阶段，而是在整个生命周期的持续投入，包括维护、监控、故障排查、适应新场景、平台等。软件在设计之初就进行充分的考虑，能够减少维护期间的麻烦。在软件设计中，应该重点关注三个原则：可运维行、简单性以及可演化性。
### 可运维性：运维更轻松
优秀的运维团队至少负责下面内容：
 * 监控系统健康性，服务异常时快速进行恢复；
 * 追踪问题的原因：如性能下降；
 * 保持软件平台的最新状态，如安全相关补丁；
 * 了解系统之间的相互影响；
 * 预测未来的一些问题，如进行容量规划；
 * 建立用于部署和配置管理的实践规范；
 * 执行复杂的维护任务，如迁移；
 * 通过流程规范操作行为，维护系统的安全稳健；
 * 相关知识的传承。
为了让可操作性变得更强，数据系统在设计时可以贡献很多，包括：
 * 提供系统运行时行为和系统内部的可观测性；
 * 支持自动化与标准工具集成；
 * 避免绑定特定机器，这样系统能够不间断运行，同时又允许机器停机维护；
 * 提供良好的文档和易于理解的操作模式；
 * 良好的默认配置
 * 尝试自我修复，需要时可让管理员手动控制状态；
 * 行为可预测，减少意外。

### 简单性
随着项目越来越大，也会变得越来越复杂，这表现为：状态空间膨胀、模块紧耦合、复杂的依赖等，复杂性会导致项目维护成本增加，开发进度缓慢。因此，简单性也是构建系统的关键目标之一。

在消除复杂性方面，最好的手段之一是抽象。好的抽象设计能够隐藏大量的实现细节，对外提供干净易懂的接口。好的抽象设计可以应用于不同的应用程序，这样复用可以带来比重复实现更高的效率，同时也带来更高质量的软件。

设计好的抽象是十分具有挑战性的，在分布式系统中，已有很多的算法，但很多时候我们不清楚如何利用它们并封装到抽象的接口中。

## 可演化性
没有一成不变的系统，想法、目标以及一些影响因素总在不断的变化。我们的目标是设计可以轻松修改的数据系统，使其能够使用不断变化的需求。可演化性也即意味着易于改变。
